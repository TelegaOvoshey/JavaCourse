import static java.lang.Math.*;
import java.util.Scanner;

public class Iffor_cycles {
    public static void main(String[] args) {
        System.out.printf("\nЗадание 1\n");
//        Даны два целых числа. Напечатайте наибольшее из них.
        int a = 2, b = 1;
        if (a > b)
            System.out.print(a);
        else
            System.out.print(b);

        System.out.printf("\nЗадание 2\n");
//        Даны два целых числа. Программа должна вывести число 1, если первое число больше второго, число 2, если второе больше первого, или число 0, если они равны.
        b = 2;
        if (a > b)
            System.out.print(1);
        else if (a < b)
            System.out.print(2);
        else
            System.out.print(0);

        System.out.printf("\nЗадание 3\n");
//        Даны три числа. Напечатайте наибольшее из них (программа должна вывести ровно одно целое число). Какое наименьшее число операторов сравнения (>, <, >=, <=) необходимо для решения этой задачи?
        int c = 3;
        if (a >= b)
            if (c <= b)
                System.out.print(a);
            else System.out.print(c);
        else if (c <= b)
            System.out.print(b);
        else System.out.print(c);

        System.out.printf("\nЗадание 4\n");
//        В математике функция sign(x) (знак числа) определена так:
//        sign(x) = 1,   если x > 0,  sign(x) = -1, если x < 0,  sign(x) = 0,   если x = 0.
//        Для данного числа x выведите значение sign(x).
        int x = -5;
        if (x > 0)
            System.out.print(1);
        else if (x == 0)
            System.out.print(0);
        else System.out.print(-1);

        System.out.printf("\nЗадание 5\n");
//        Даны три целых числа. Определите, сколько среди них совпадающих. Программа должна вывести одно из чисел: 3 (если все совпадают), 2 (если два совпадает) или 0 (если все числа различны).
        if (a == b)
            if (b == c)
                System.out.print(3);
            else System.out.print(2);
        else if (a == c || b == c)
            System.out.print(2);
        else System.out.print(1);

        System.out.printf("\nЗадание 6\n");
//        Поле шахматной доски определяется парой чисел (a, b), каждое от 1 до 8, первое число задает номер столбца, второе – номер строки. Заданы две клетки. Определите, может ли шахматная ладья попасть с первой клетки на вторую за один ход. Входные данные: 4 целых числа от 1 до 8 каждое, первые два задают начальную клетку, вторые два задают конечную клетку. Начальные и конечные клетки не совпадают. Программа должна вывести YES, если из первой клетки ходом ладьи можно попасть во вторую или NO в противном случае.
        int a1 = 2, b1 = 1, a2 = 6, b2 = 1;
        if ((a1 == a2) || (b1 == b2)) System.out.print("YES");
        else System.out.print("NO");

        System.out.printf("\nЗадание 7\n");
//        Даны действительные числа a, b, c. Найдите все решения квадратного уравнения ax2+bx+c=0. Формат входных данных: три действительных числа. Формат выходных данных: два действительных числа, если уравнение имеет два корня, одно действительное число – при наличии одного корня. При отсутствии действительных корней программа не выводит ничего.
        if (sqrt(b) - 4 * a * c > 0)
            System.out.print(-b - sqrt(sqrt(b) - 4 * a * c) / (2 * a) + " " + -b + sqrt(sqrt(b) - 4 * a * c) / (2 * a));
        else if (sqrt(b) - 4 * a * c == 0)
            System.out.print(-b / (2 * a) + "b");

        System.out.printf("\nЗадание 8\n");
//        Определите тип треугольника (остроугольный, тупоугольный, прямоугольный) с данными сторонами. Входные данные: три натуральных числа – стороны треугольника. Выходные данные: одно из слов rectangular для прямоугольного треугольника, acute для остроугольного треугольника, obtuse для тупоугольного треугольника или impossible, если входные числа не образуют треугольника.
        a = 3;
        b = 4;
        c = 5;
        int bisector = 0, cath1 = 0, cath2 = 0;
        if ((a + b <= c) || (a + c <= b) || (b + c <= a))
            System.out.print("impossible");
        else if (a >= b)
            if (a >= c) {
                bisector = a;
                cath1 = b;
                cath2 = c;
            } else {
                bisector = c;
                cath1 = a;
                cath2 = b;
            }
        else if (c >= b) {
            bisector = c;
            cath1 = a;
            cath2 = b;
        } else {
            bisector = b;
            cath1 = a;
            cath2 = c;
        }
        cath1 *= cath1;
        cath2 *= cath2;
        bisector *= bisector;
        if (cath1 + cath2 > bisector)
            System.out.print("acute");
        else if (cath1 + cath2 < bisector)
            System.out.print("obtuse");
        else
            System.out.print("rectangular");

        System.out.printf("\nЗадание 9\n");
//        Билет на одну поездку в метро стоит 15 рублей, билет на 10 поездок стоит 125 рублей, билет на 60 поездок стоит 440 рублей. Пассажир планирует совершить n поездок. Определите, сколько билетов каждого вида он должен приобрести, чтобы суммарное количество оплаченных поездок было не меньше n, а общая стоимость приобретенных билетов – минимальна. Входные данные: количество поездок n. Выходные данные – три целых числа, равные необходимому количеству билетов на 1, на 10, на 60 поездок. Например, при вводе 129 программа должна вывести 0 1 2 (2 билета на 60 поездок и 1 билет на 10 поездок).
        int bilet = 0, bilet10 = 0, bilet60 = 0, n = 129;
        bilet60 = n / 60;
        n %= 60;
        if (n >= 35)
            bilet60++;
        else {
            bilet10 = n / 10;
            n %= 10;
            if (n >= 9)
                bilet10++;
            else
                bilet = n;
        }
        System.out.printf(bilet + " " + bilet10 + " " + bilet60);

        System.out.printf("\nЗадание 10\n");
//        Решите предыдущую задачу при наличии следующих билетов: 1 поездка - 15 рублей, 5 поездок - 70 рублей, 10 поездок - 125 рублей, 20 поездок - 230 рублей, 60 поездок - 440 рублей. Если для какого-то данного n существует несколько способов приобретения билетов одинаковой стоимости, необходимо вывести ту комбинацию билетов, которая дает большее число поездок.
        int bilet20 = 0, bilet5 = 0;
        bilet = 0;
        bilet10 = 0;
        bilet60 = 0;
        n = 129;
        bilet60 = n / 60;
        n %= 60;
        if (n >= 35)
            bilet60++;
        else {
            bilet20 = n / 20;
            n %= 20;
            if (n >= 18)
                bilet20++;
            else {
                bilet10 = n / 10;
                n %= 10;
                if (n >= 9)
                    bilet10++;
                else {
                    bilet5 = n / 5;
                    n %= 5;
                    if (n >= 4)
                        bilet5++;
                    else {
                        bilet = n;
                    }
                }
            }
        }
        System.out.printf(bilet + " " + bilet5 + " " + bilet10 + " " + bilet20 + " " + bilet60);//что с одинаковой стоимостью?

        System.out.printf("\nЗадание 11\n");
//        По данному натуральному n вычислите сумму 1^2+2^2+...+n^2.
        n = 2;
        int sum = 0;
        for (int i = 0; i < n + 1; i++)
            sum = sum + i * i;
        System.out.print(sum);

        System.out.printf("\nЗадание 12\n");
//       По данному натуральному n вычислите сумму 1×2+2×3+...+(n-1)×n.
        n = 3;
        sum = 0;
        for (int i = 1; i < n + 1; i++)
            sum += (n - 1) * n;
        System.out.print(sum);

        System.out.printf("\nЗадание 13\n");
//      По данному натуральному n вычислите сумму 1+(1+2)+(1+2+3)+...+(1+2+...+n).
        n = 3;
        sum = 0;
        for (int i = 1; i < n + 1; i++)
            for (int j = 1; j <= i; sum += j++) ;
        System.out.print(sum);

        System.out.printf("\nЗадание 14\n");
//        По данным числам a и b выведите на экран все четные числа от a до b включительно.
//        Например, при вводе 1 и 10 программа должна вывести 2 4 6 8 10.
        a = 3;
        b = 10;
        for (int i = a; i <= b; i++)
            if (i % 2 == 0)
                System.out.printf(i + " ");

        System.out.printf("\nЗадание 15\n");
//        По данному числу n вычислите значение n! (факториал).
        sum = 1;
        n = 5;
        for (; n > 0; sum *= n--) ;
        System.out.print(sum);

        System.out.printf("\nЗадание 16\n");
//        По данным натуральным n и k вычислите значение Cnk=n!/(k!(n-k)!) (число сочетаний из n элементов по k).
        n = 5;
        int k = 2;
        sum = 1;
        for (int i = 1; i <= k; i++) {
            sum *= (n - k + i);
            sum /= i;
        }
        System.out.print(sum);

        System.out.printf("\nЗадание 17\n");
//      По данному действительному числу a и натуральному n вычислите величину an. Программа считывает значение a и n и выводит an.
//      Указание:  в степень можно гораздо быстрее, чем за n умножений! Для этого нужно воспользоваться следующими рекуррентными соотношениями:  n 2 n2
//      a =(a ) при четном n, an=a*an−1 при нечетном n.
//      Сложность данного алгоритма - O(logn).
        n = 2;
        a = 3;
        System.out.print(pow(a, n));

        System.out.printf("\nЗадание 18\n");
//        По данному числу n вычислите сумму 1+1/2^2+1/3^2+...+1/n^2. Как вы думаете, к чему приближается эта сумма с увеличением n?
        n = 4;
        for (int i = 1; i <= n; i++) {
            sum += (1 / pow(i, 2));
        }
        System.out.print(pow(a, n));

        System.out.printf("\nЗадание 19\n");
//        По данному числу n вычислите сумму 4(1-1/3+1/5-1/7+...+(-1)n/(2n+1)). Как вы думаете, к чему будет приближаться эта сумма с увеличением n?
        n = 100;
        double s = 1;
        for (int i = 1; i <= n; i++) {
            s += pow(-1, i) / (2 * i + 1);
        }
        System.out.print(s * 4);

        System.out.printf("\nЗадание 20\n");
//        По данному действительному числу a и натуральному n вычислите сумму 1+a+a2+...+an не используя формулу суммы геометрической прогрессии. Время работы программы должно быть пропорционально n. Затем решите эту задачу по формуле суммы геометрической прогрессии.
        System.out.printf("Без формулы геометрической прогрессии\n");
        sum = 1;
        a = 6;
        n = 5;
        for (int i = 1; i < n; i++)
            sum += pow(a, i);
        System.out.print(sum);
        System.out.printf("\nС формулой геометрической прогрессии\n");
        s = (pow(a, n) - 1) / (a - 1);
        System.out.print(s);

        System.out.printf("\nЗадание 21\n");
//        Дано несколько чисел. Вычислите их сумму.
//        Сначала вводится количество чисел N. Затем вводится N целых чисел, программа должна вывести их сумму.
//        Например, при вводе 3 1 20 300 программа должна вывести 321.
        Scanner in = new Scanner(System.in);
        System.out.printf("\nВведите данные\n");
        n=in.nextInt();
        sum=0;
        for (int i=0;i<n;i++)
        {
            sum+=in.nextInt();
        }
        System.out.print(sum);

        System.out.printf("\nЗадание 22\n");
//        Найдите все двузначные числа, которые равны удвоенному произведению своих цифр. Указание: организуйте цикл, в котором переменная i принимает значения от 10 до 99, проверьте, равна ли i удвоенному произведению своих цифр.
        for (int i = 10; i < 99; i++) {
            if (i == 2 * (i % 10) * (i / 10))
                System.out.print(i);
        }

        System.out.printf("\nЗадание 23\n");
//        Квадрат трехзначного числа оканчивается тремя цифрами, равными этому числу. Найдите все такие числа.
        for (int i = 100; i < 1000; i++) {
            if (i*i%1000==i)
                System.out.print(i);
        }
    }

    static double pow(double a, double n) {
        if (n == 0) return 1;
        if (n % 2 == 0) return pow(a*a, n/2);
        return a*pow(a, n-1);
    }
}
